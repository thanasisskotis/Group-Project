\documentclass{article}
\usepackage[greek,english]{babel}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{fullpage}

\begin{document}
\author{}
\date{}

\section*{Exercise 2}

\begin{algorithm}
\caption{\begin{otherlanguage}{greek}Βρες την Ειδική Κορυφή σε $O(n)$ (με πίνακα γειτνίασης)\end{otherlanguage}}
\begin{algorithmic}[1]
\State \textbf{\begin{otherlanguage}{greek}Είσοδος:\end{otherlanguage}} \begin{otherlanguage}{greek}Πίνακας γειτνίασης $G[1\ldots n][1\ldots n]$ για γράφημα με $n$ κορυφές.\end{otherlanguage}
\State \textbf{\begin{otherlanguage}{greek}Έξοδος:\end{otherlanguage}} \begin{otherlanguage}{greek}\texttt{True} αν υπάρχει ειδική κορυφή, αλλιώς \texttt{False}.\end{otherlanguage}
\State

\State \begin{otherlanguage}{greek}υποψήφιος $\gets 1$\end{otherlanguage}
\For{$i = 2$ \textbf{\begin{otherlanguage}{greek}μέχρι\end{otherlanguage}} $n$}
    \If{$G$[\begin{otherlanguage}{greek}υποψήφιος\end{otherlanguage}]$[i] = 1$}
        \State \begin{otherlanguage}{greek}υποψήφιος $\gets i$\end{otherlanguage}
    \EndIf
\EndFor

\State


\For{$i = 1$ \textbf{\begin{otherlanguage}{greek}μέχρι\end{otherlanguage}} $n$}
    \If{$i =$ \begin{otherlanguage}{greek}υποψήφιος\end{otherlanguage}}
        \State \textbf{\begin{otherlanguage}{greek}συνέχισε\end{otherlanguage}}
    \EndIf
    \If{$G[i]$[\begin{otherlanguage}{greek}υποψήφιος\end{otherlanguage}]$ = 0$ \textbf{ή} $G$[\begin{otherlanguage}{greek}υποψήφιος\end{otherlanguage}]$[i] = 1$}
        \State \Return \texttt{$False$}
    \EndIf
\EndFor
\State \Return \texttt{$True$}
\end{algorithmic}
\end{algorithm}


\begin{otherlanguage}{greek}
Ο αλγόριθμος εντοπίζει αν υπάρχει μία ειδική κορυφή $c$ στο γράφημα με τις εξής ιδιότητες:
\begin{itemize}
    \item Για κάθε $i \neq c$, υπάρχει ακμή $(i, c)$
    \item Για κάθε $i \neq c$, δεν υπάρχει ακμή $(c, i)$
\end{itemize}


Ο αλγόριθμος αποτελείται από δύο φάσεις:\\
\end{otherlanguage}


\textbf{\begin{otherlanguage}{greek}Βήμα 1: Επιλογή Υποψήφιου\end{otherlanguage}}

\begin{otherlanguage}{greek}
Αρχικά θεωρούμε τον κόμβο $1$ ως υποψήφιο. Για κάθε επόμενο κόμβο $i$ από $2$ έως $n$, ελέγχουμε:

\begin{itemize}
    \item Αν ο τρέχων υποψήφιος έχει ακμή προς $i$, τότε ο υποψήφιος απορρίπτεται (δεν είναι η ειδική κορυφή), και το $i$ γίνεται ο νέος υποψήφιος.
    \item Αλλιώς, το $i$ δεν μπορεί να είναι η ειδική κορυφή γιατί υπάρχει κάποιος που δεν τον γνωρίζει, και κρατάμε τον ίδιο υποψήφιο.
\end{itemize}

Στο τέλος του πρώτου βήματος, μένει ένας μοναδικός υποψήφιος που ενδέχεται να είναι η ειδική κορυφή.
\end{otherlanguage}\\

\textbf{\begin{otherlanguage}{greek}Βήμα 2: Έλεγχος Εγκυρότητας\end{otherlanguage}}

\begin{otherlanguage}{greek}
Για κάθε κόμβο $i \neq$ υποψήφιος, ελέγχουμε:
\begin{itemize}
    \item Αν \texttt{γνωρίζει($i$, υποψήφιος)} είναι \texttt{$False$}, τότε απορρίπτεται.
    \item Αν \texttt{γνωρίζει(υποψήφιος, $i$)} είναι \texttt{$True$}, τότε επίσης απορρίπτεται.
\end{itemize}

\paragraph{Συμπέρασμα:} Αν περάσει τον έλεγχο, επιστρέφεται \texttt{$True$}, αλλιώς \texttt{$False$}.
\end{otherlanguage}

\paragraph{\begin{otherlanguage}{greek}Χρονική Πολυπλοκότητα:\end{otherlanguage}} $O(n)$ \begin{otherlanguage}{greek} για τον 1ο βρόχο επανάληψης και $Ο(n)$ και στο 2ο βρόχο επανάληψης άρα στο σύνολο έχουμε $O(n) + O(n) = O(n)$ , άρα αλγοριθμικά βέλτιστος.\end{otherlanguage}






\section*{Exercise 4}

\begin{algorithm}
\caption{\begin{otherlanguage}{greek}Χρωματισμός Διαστημάτων με Ελάχιστα Χρώματα \end{otherlanguage}}
\begin{algorithmic}[1]
\State \begin{otherlanguage}{greek}Είσοδος: Πίνακας $Set = \{(l_i, r_i)\}_{i=1}^n$ από $n$ ανοιχτά διαστήματα.\end{otherlanguage}
\State \begin{otherlanguage}{greek}Ταξινόμησε τα διαστήματα κατά αύξον $l_i$.\end{otherlanguage}
\State \begin{otherlanguage}{greek}Αρχικοποίησε πίνακα $ColourArray[1 \ldots n] \gets 0$\end{otherlanguage}
\State \begin{otherlanguage}{greek}Αρχικοποίησε κενό $set$ για διαθέσιμα χρώαματα $AvailableColours$\end{otherlanguage}
\State \begin{otherlanguage}{greek}Αρχικοποίησε $CurrentColour \gets 1$\end{otherlanguage}
\State \begin{otherlanguage}{greek}Αρχικοποίησε κενή \end{otherlanguage} priority queue $PQ$ \begin{otherlanguage}{greek} με στοιχεία της μορφής $(r_i, \text{χρώμα})$ ταξινομημένα κατά $r_i$\end{otherlanguage}
\For{$i \gets 1$ \textbf{to} $n$}
    \While{\begin{otherlanguage}{greek}$PQ$ δεν είναι κενή \textbf{και} $PQ.top().first \leq l_i$\end{otherlanguage}}
        \State \begin{otherlanguage}{greek}Αφαίρεσε ($r$, χρώμα) από $PQ$\end{otherlanguage}
        \State \begin{otherlanguage}{greek}Πρόσθεσε \textbf{χρώμα} στο $AvailableColours$\end{otherlanguage}
    \EndWhile
    \If{\begin{otherlanguage}{greek}υπάρχει διαθέσιμο χρώμα\end{otherlanguage}}
        \State \begin{otherlanguage}{greek}Ανάθεσε στον πίνακα $ColourArray[i]$ ένα διαθέσιμο χρώμα από το $AvailableColours$\end{otherlanguage}
    \Else
        \State \begin{otherlanguage}{greek}$ColourArray[i] \gets CurrentColour$\end{otherlanguage}
        \State \begin{otherlanguage}{greek}$CurrentColour \gets CurrentColour + 1$\end{otherlanguage}
    \EndIf
    \State \begin{otherlanguage}{greek}Προσθήκη $(r_i, ColourArray[i])$ στο $PQ$\end{otherlanguage}
\EndFor
\State \Return \begin{otherlanguage}{greek}$ColourArray[1 \ldots n]$\end{otherlanguage}
\end{algorithmic}
\end{algorithm}


\subsection*{\begin{otherlanguage}{greek}Απόδειξη Ορθότητας και Πολυπλοκότητας Αλγορίθμου Χρωματισμού\end{otherlanguage}}

\paragraph{\begin{otherlanguage}{greek}Ιδιότητες που πρέπει να αποδείξουμε:\end{otherlanguage}}

\begin{otherlanguage}{greek}
\begin{itemize}
    \item[(1)] Ο αλγόριθμος δεν αναθέτει ποτέ το ίδιο χρώμα σε δύο επικαλυπτόμενα διαστήματα.
    \item[(2)] Ο αριθμός χρωμάτων που χρησιμοποιούνται είναι ελάχιστος δυνατός.
\end{itemize}
\end{otherlanguage}\\

\textbf{\begin{otherlanguage}{greek}Απόδειξη ιδιότητας (1):\end{otherlanguage}}\begin{otherlanguage}{greek} Κανένα δύο επικαλυπτόμενα διαστήματα δεν έχουν το ίδιο χρώμα.\end{otherlanguage}

\begin{otherlanguage}{greek}
Έστω ότι το διάστημα $I_i = (l_i, r_i)$ παίρνει ένα χρώμα $c$ από το σύνολο των διαθέσιμων χρωμάτων $AvailableColours$.

Αυτό σημαίνει ότι το χρώμα $c$ είχε ανατεθεί σε κάποιο προηγούμενο διάστημα $I_j = (l_j, r_j)$, το οποίο όμως είχε ήδη αφαιρεθεί από την ουρά $PQ$ (άρα $r_j \leq l_i$), δηλαδή το $I_j$ έχει τελειώσει πριν ξεκινήσει το $I_i$.

Επομένως, τα $I_j$ και $I_i$ δεν επικαλύπτονται, άρα είναι ασφαλές να χρησιμοποιήσουμε ξανά το ίδιο χρώμα $c$.

Ομοίως, αν το $I_i$ λάβει νέο χρώμα $c$ (δεν υπάρχει διαθέσιμο), αυτό σημαίνει ότι επικαλύπτεται με όλα τα ενεργά διαστήματα που βρίσκονται στην $PQ$, τα οποία έχουν διαφορετικά χρώματα.

Άρα, κανένα δύο επικαλυπτόμενα διαστήματα δεν έχουν το ίδιο χρώμα.
\end{otherlanguage}\\

\textbf{\begin{otherlanguage}{greek}Απόδειξη ιδιότητας (2):\end{otherlanguage} } \begin{otherlanguage}{greek} Ο αριθμός χρωμάτων είναι ελάχιστος.\end{otherlanguage}

\begin{otherlanguage}{greek}
Το πλήθος των χρωμάτων που χρησιμοποιούνται αντιστοιχεί στον μέγιστο αριθμό επικαλυπτόμενων διαστημάτων σε οποιοδήποτε χρονικό σημείο. Ο λόγος είναι ότι το χρώμα επαναχρησιμοποιείται αμέσως μόλις το αντίστοιχο διάστημα τελειώσει.

Δηλαδή, ένα νέο χρώμα δημιουργείται μόνο όταν το τρέχον διάστημα επικαλύπτεται με όλα τα προηγούμενα "ενεργά" διαστήματα, και δεν υπάρχει κανένα χρώμα διαθέσιμο.

\end{otherlanguage}\\



\begin{otherlanguage}{greek}
Άρα αλγόριθμος αναθέτει έγκυρα χρώματα χωρίς επικαλύψεις, και χρησιμοποιεί τον ελάχιστο δυνατό αριθμό χρωμάτων για τη χρωμάτιση των διαστημάτων.
\end{otherlanguage}\\


\textbf{\begin{otherlanguage}{greek}Πολυπλοκότητα:\end{otherlanguage}}

\begin{otherlanguage}{greek}
Αναλύουμε τα βήματα του αλγορίθμου:

\begin{itemize}
    \item Ταξινόμηση των $n$ διαστημάτων κατά $l_i$: $O(n \log n)$
    \item Για κάθε διάστημα( $O(n)$ ):
    \begin{itemize}
        \item Εισαγωγή ή αφαίρεση από το \begin{otherlanguage}{english}priority queue: \end{otherlanguage} $O(\log n)$
        \item Αναζήτηση/εκχώρηση χρώματος: $O(1)$ με διαχείριση διαθέσιμων χρωμάτων ($set$).
    \end{itemize}
\end{itemize}

Άρα $O(nlogn)$

\textbf{Συνολικά:} $O(n \log n) + O(n \log n) = O(n \log n)$ λόγω της ταξινόμησης και των προσθηκών/αφαιρέσεων στη ουρά προτεραιότητας ανά διάστημα.

\paragraph{Βέλτιστοτητα:} Ο αλγόριθμος είναι βέλτιστος για τα διαστηματά μας, καθώς ο ελάχιστος αριθμός χρωμάτων είναι ίσος με τη μέγιστη ταυτόχρονη επικάλυψη, κάτι που επιτυγχάνεται εδώ.
\end{otherlanguage}



\end{document}
