\documentclass{article}
\usepackage[greek,english]{babel}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{fullpage}
\usepackage{textgreek}


\begin{document}

\section*{Exercise 1}
\section*{\textgreek{Περιγραφή Αλγορίθμου: }}
\begin{enumerate}
    \item \textgreek{Αρχικοποίηση του πίνακα αποστάσεων:}
    \[
    \text{dist}[i][j] =
    \begin{cases}
    w(i, j), & \textgreek{αν υπάρχει ακμή } i \rightarrow j \\
    \infty, & \textgreek{διαφορετικά}
    \end{cases}
    \]
    \item \textgreek{Για κάθε κόμβο $k \in V$, και για κάθε ζεύγος κόμβων $i, j \in V$, βρίσκουμε τη συντομότερη διαδρομή μεταξύ $i$ και $j$}:
    \[
    \text{dist}[i][j] = \min(\text{dist}[i][j], \text{dist}[i][k] + \text{dist}[k][j])
    \]
    \item \textgreek{Ο συντομότερος κύκλος δίνεται από:}
    \[
    \min_{v \in V} \text{dist}[v][v]
    \]
    Αν $\text{dist}[v][v] = \infty$ \textgreek{για όλα τα $v$, τότε το γράφημα δεν περιέχει κύκλο.}
\end{enumerate}

\section*{\textgreek{Ψευδοκώδικας:}}

\begin{algorithm}
\caption{\textgreek{Συντομότερος Κατευθυνόμενος Κύκλος}}
\begin{algorithmic}[1]
\Statex \textgreek{Είσοδος: Γράφος $G = (V, A)$ με θετικά βάρη $w(u, v)$}
\Statex \textgreek{Έξοδος: Μήκος του συντομότερου κατευθυνόμενου κύκλου ή \texttt{None} αν δεν υπάρχει κύκλος}

\State Αρχικοποίησε τον πίνακα \texttt{dist[$n$][$n$]} ως εξής:
\ForAll{$i, j \in V$}
    \If{$i = j$}
        \State \texttt{dist[$i$][$j$]} $\gets 0$
    \ElsIf{$(i, j) \in A$}
        \State \texttt{dist[$i$][$j$]} $\gets w(i, j)$
    \Else
        \State \texttt{dist[$i$][$j$]} $\gets \infty$
    \EndIf
\EndFor

\For{$k = 1$ to $n$}
    \For{$i = 1$ to $n$}
        \For{$j = 1$ to $n$}
            \State \texttt{dist[$i$][$j$]} $\gets \min(\texttt{dist[$i$][$j$]}, \texttt{dist[$i$][$k$]} + \texttt{dist[$k$][$j$]})$
        \EndFor
    \EndFor
\EndFor

\State \texttt{minCycle} $\gets \infty$
\For{$v = 1$ to $n$}
    \State \texttt{minCycle} $\gets \min(\texttt{minCycle}, \texttt{dist[$v$][$v$]})$
\EndFor

\If{\texttt{minCycle = $\infty$}}
    \State \Return \texttt{None}
\Else
    \State \Return \texttt{minCycle}
\EndIf

\end{algorithmic}
\end{algorithm}

\section*{\textgreek{Ανάλυση Πολυπλοκότητας: }}

\textgreek{Ο αλγόριθμος αποτελείται από τρεις εμφωλευμένους βρόγχους επανάληψης. Έστω \( n = |V| \)}

\subsection*{Main Loop}

\textgreek{Υπολογίζουμε: }
\[
\text{dist}[i][j] = \min(\text{dist}[i][j], \text{dist}[i][k] + \text{dist}[k][j])
\]
\textgreek{για κάθε } \( i, j, k \in \{1, 2, \dots, n\} \).

\subsection*{\textgreek{Συνολικός αριθμός πράξεων τριπλού βρόγχου:} }

\textgreek{Αθροίζουμε ως προς όλους τους συνδυασμούς \( i, j, k \):}

\sum_{k=1}^{n} \sum_{i=1}^{n} \sum_{j=1}^{n} O(1) = O(n) \cdot O(n) \cdot O(n) = O(n^3)

\subsection*{\textgreek{Μετά από την επεξεργασία μέσω του τριπλού βρόγχου επανάληψης: }}

\textgreek{\textgreek{Έλεγχος διαγώνιων στοιχείων για την εύρεση συντομότερου κύκλου: }}
\[
\min_{v \in V} \text{dist}[v][v]
\]
\textgreek{Αυτό απαιτεί: }  \sum_{v=1}^{n} O(1) = O(n)  \textgreek{ πράξεις.}

\subsection*{\textgreek{Συνολική πολυπλοκότητα: }}

T(n) = \sum_{k=1}^{n} \sum_{i=1}^{n} \sum_{j=1}^{n} O(1) + \sum_{v=1}^{n} O(1) = O(n^3) 
+ O(n) = \mathcal{O}(n^3)



\section*{\textgreek{Απόδειξη Ορθότητας}}

\textgreek{Έστω $V = \{1, 2, \dots, n\}$ το σύνολο των κόμβων. Ορίζουμε τη συντομότερη διαδρομή από $i$ σε $j$ χρησιμοποιώντας μόνο ενδιάμεσους κόμβους από το υποσύνολο $\{1, 2, \dots, k\}$. Την ονομάζουμε $\delta_k(i,j)$. Η επαγωγική υπόθεση ορίζει ότι για κάθε $k$, ισχύει η εξής αναδρομική σχέση:}

\[
\delta_k(i,j) = \min \left\{ \delta_{k-1}(i,j),\ \delta_{k-1}(i,k) + \delta_{k-1}(k,j) \right\}
\]
\textgreek{
\begin{itemize}
    \item Για $k = 0$, η $\delta_0(i,j)$ είναι:
    \[
    \delta_0(i,j) =
    \begin{cases}
    w(i,j), & \text{αν υπάρχει ακμή } (i,j) \in A \\
    \infty, & \text{διαφορετικά}
    \end{cases}
    \]
    \item Έστω ότι η πρόταση ισχύει για $k-1$, και εξετάζουμε την περίπτωση $k$:
    \begin{itemize}
        \item Αν η συντομότερη διαδρομή από $i$ σε $j$ **δεν περιλαμβάνει τον $k$** ως ενδιάμεσο κόμβο, τότε όλοι οι ενδιάμεσοι κόμβοι ανήκουν στο $\{1, \dots, k-1\}$ και:
        \[
        \delta_k(i,j) = \delta_{k-1}(i,j)
        \]
        \item Αν η διαδρομή περιλαμβάνει τον $k$ ως ενδιάμεσο, τότε διασπάται σε δύο διαδρομές:
        \[
        \delta_k(i,j) = \delta_{k-1}(i,k) + \delta_{k-1}(k,j)
        \]
        που σύμφωνα με την επαγωγική υπόθεση είναι σωστές.
    \end{itemize}
\end{itemize}
}
\textgreek{
Επομένως, η αναδρομική σχέση υπολογίζει σωστά το $\delta_k(i,j)$ για κάθε $k$, και τελικά το $\delta_n(i,j)$ είναι η συντομότερη διαδρομή από $i$ σε $j$.}

\section*{\textgreek{Εύρεση Κύκλου}}
\textgreek{
Η συντομότερη κατευθυνόμενη κυκλική διαδρομή είναι μια διαδρομή που ξεκινά και καταλήγει στον ίδιο κόμβο. Άρα για κάθε $v \in V$ η ποσότητα} $\text{dist}[v][v]$ \textgreek{περιέχει το μήκος της συντομότερης κυκλικής διαδρομής που περνά από το $v$.}

\textgreek{Το ελάχιστο αυτών:}
\[
\min_{v \in V} \text{dist}[v][v]
\]
\textgreek{είναι το μήκος του συντομότερου κατευθυνόμενου κύκλου.}



\section*{Exercise 3}

\begin{algorithm}
\caption{Find Path Between Two Vertices in MST (BFS)}
\begin{algorithmic}[1]
\Function{find\_path}{start, end}
    \State \textgreek{Αρχικοποίηση ουράς} \( q \gets \{start\} \)
    \State \( \text{visited[start]} \gets \text{True} \)
    \While{\( q \) is not empty}
        \State \( \text{node} \gets q.pop() \)
        \If{\( \text{node} == \text{end} \)}
           \Comment{ \textgreek{Ανακατασκευή του μονοπατιού χρησιμοποιώντας τον πίνακα}} \textnormal{parent}
            \State \( \text{curr} \gets \text{end} \)
            \While{\( \text{curr} \ne \text{start} \)}
                \State \( \text{prev} \gets \text{parent[curr]} \)
                \State \( \text{curr} \gets \text{prev} \)
            \EndWhile
            \State \Return \text{True}
        \EndIf
        \ForAll{neighbor \( \in \text{adj\_list[node]} \)}
            \If{not \( \text{visited[neighbor]} \)}
                \State \( \text{visited[neighbor]} \gets \text{True} \)
                \State \( \text{parent[neighbor]} \gets \text{node} \)
                \State \( q.push(neighbor) \)
            \EndIf
        \EndFor
    \EndWhile
    \State \Return False
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Handle Weight Increase}
\begin{algorithmic}[1]
\State \textgreek{Είσοδος: } \( V, \text{graph\_edges}, \text{mst\_edges}, \text{edge\_to\_remove} \)
\State \textgreek{Έξοδος: } \textgreek{Λίστα με ακμές ενημερωμένου ΕΕΔ}
\State \text{adj\_list} \(\gets\) \textgreek{Άδεια λίστα γειτνίασης μεγέθους \( V \)} 
\For{each edge \( e \in \text{mst\_edges} \)}
    \If{not \((e.u == \text{edge\_to\_remove}.u \text{ and } e.v == \text{edge\_to\_remove}.v)\) or \((e.u == \text{edge\_to\_remove}.v \text{ and } e.v == \text{edge\_to\_remove}.u)\))}
        \State \text{adj\_list[e.u].append(e.v)}
        \State \text{adj\_list[e.v].append(e.u)}
    \EndIf
\EndFor

\State \text{visited} \(\gets\) Array of False values for \( V \)
\State \text{component} \(\gets\) Array of 0 values for \( V \)
\State \text{comp\_id} \(\gets\) 1

\For{i = 0 to V-1}
    \If{visited[i] is False}
        \State \text{bfs(i, comp\_id)}  \Comment{\textgreek{\(bfs\) για να βρούμε τις συνιστώσες}}
        \State comp\_id \(\gets\) comp\_id + 1
    \EndIf
\EndFor

\If{\( \text{component[edge\_to\_remove.u]} == \text{component[edge\_to\_remove.v]} \)}
    \State \textbf{return} \text{mst\_edges}
\EndIf

\State \text{min\_edge} \(\gets\) None
\For{each edge \( e \in \text{graph\_edges} \)}
    \If{\( \text{component[e.u]} \neq \text{component[e.v]} \)}
        \If{min\_edge is None or \( e.\text{weight} < \text{min\_edge.weight} \)}
            \State \( \text{min\_edge} \gets e \)
        \EndIf
    \EndIf
\EndFor

\State \text{result} \(\gets\) List of edges in \text{mst\_edges} excluding \text{edge\_to\_remove}
\If{min\_edge is not None}
    \State \text{result.append(min\_edge)}
\EndIf

\State \textbf{return} result
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{DFS}
\begin{algorithmic}[1]
\Procedure{DFS}{$node$, $target$, $adjList$, $visited$, $parent$, $edgeToParent$}
    \If{$node = target$}
        \State \Return \textbf{true}
    \EndIf
    \State $visited[node] \gets true$
    \ForAll{$(neighbor, edge)$ in $adjList[node]$}
        \If{\textbf{not} $visited[neighbor]$}
            \State $parent[neighbor] \gets node$
            \State $edgeToParent[neighbor] \gets edge$
            \If{\Call{DFS}{$neighbor$, $target$, $adjList$, $visited$, $parent$, $edgeToParent$}}
                \State \Return \textbf{true}
            \EndIf
        \EndIf
    \EndFor
    \State \Return \textbf{false}
\EndProcedure
\end{algorithmic}
\end{algorithm}

\vspace{1em}

\begin{algorithm}
\caption{Handle Reduced Weight($V$, $graphEdges$, $mstEdges$, $u$, $v$, $newWeight$)}
\begin{algorithmic}[1]
\State \textgreek{Αρχικοποίησε λίστα γειτνίασης} $adjList[0 \dots V-1] \gets \textgreek{Άδειες λίστες}$
\ForAll{$e \in mstEdges$}
    \State Add $(e.v, e)$ to $adjList[e.u]$ and $(e.u, e)$ to $adjList[e.v]$
\EndFor

\State \textgreek{Αρχικοποίησε πίνακες}: $visited[0 \dots V-1] \gets false$, $parent[0 \dots V-1] \gets -1$, $edgeToParent[0 \dots V-1] \gets \text{None}$

\If{\textbf{not} \Call{DFS}{$u$, $v$, $adjList$, $visited$, $parent$, $edgeToParent$}}
    \State \Return $mstEdges$
\EndIf

\State $curr \gets v$, $maxEdge \gets$ None
\While{$curr \ne u$}
    \State $edge \gets edgeToParent[curr]$
    \If{$maxEdge = \text{None}$ \textbf{or} $edge.weight > maxEdge.weight$}
        \State $maxEdge \gets edge$
    \EndIf
    \State $curr \gets parent[curr]$
\EndWhile

\If{$maxEdge \ne \text{None}$ \textbf{and} $maxEdge.weight > newWeight$}
    \State $newMST \gets$ all edges in $mstEdges$ except $maxEdge$
    \State Add edge $(u, v, newWeight)$ to $newMST$
    \State \Return $newMST$
\EndIf

\State \Return $mstEdges$
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\caption{Update MST }
\begin{algorithmic}[1]
\State \textgreek{Είσοδος: }
\State \quad \( V \) (\textgreek{Αριθμός Κορυφών})
\State \quad \( \text{graph\_edges} \) \textgreek{Λίστα ακμών με τα βάρη τους}
\State \quad \( \text{mst\_edges} \) \textgreek{Λίστα ακμών στο παρών ΕΕΔ}
\State \quad \( u, v \) \textgreek{Κορυφές της ακμής που ενημερώνεται}
\State \quad \( \text{new\_weight} \) \textgreek{ (Νέο βάρος της ακμής \( (u, v) \))}
\State \textgreek{Έξοδος: } \textgreek{Λίστα με τις ακμές του ενημερωμένου ΕΕΔ}

\State \( \text{old\_weight} \gets \text{None} \)
\For{each edge \( e \in \text{graph\_edges} \)}
    \If{(e.u == u and e.v == v) or (e.u == v and e.v == u)}
        \State \( \text{old\_weight} \gets e.\text{weight} \)
        \State \( e.\text{weight} \gets \text{new\_weight} \)
        \State \textbf{break}
    \EndIf
\EndFor

\If{\( \text{old\_weight} \) is \( \text{None} \)}
    \State \text{return None}  \Comment{\textgreek{Η ενημερωμένη ακμή δεν βρέθηκε στον γράφο}}
\EndIf

\State \( \text{edge\_in\_mst} \gets \text{None} \)
\For{each edge \( e \in \text{mst\_edges} \)}
    \If{(e.u == u and e.v == v) or (e.u == v and e.v == u)}
        \State \( \text{edge\_in\_mst} \gets e \)
        \State \( e.\text{weight} \gets \text{new\_weight} \)
        \State \textbf{break}
    \EndIf
\EndFor

\If{edge\_in\_mst is not None and new\_weight \(>\) old\_weight}
    \State \textbf{return} \texttt{handle\_weight\_increase}(V, graph\_edges, mst\_edges, edge\_in\_mst)
\EndIf

\If{edge\_in\_mst is None and new\_weight \(<\) old\_weight}
    \State \textbf{return} \texttt{handle\_weight\_decrease}(V, graph\_edges, mst\_edges, u, v, new\_weight)
\EndIf

\State \textbf{return} mst\_edges
\end{algorithmic}
\end{algorithm}

\end{document}

